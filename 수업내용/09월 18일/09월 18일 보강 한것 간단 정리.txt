


속성과 행동을 모은것 -> 캡슐화(인캡슐레이션)


디렉토리의 경로를 따로 저장하는 방식 사용.

이벤트의 타입과 키를 튜플로 사용

애니메이션은 클립 드로우 사용

객체가 속성들을 가지고 있게 한다.

객체 생성 방식 class Boy;
boy = Boy()

클래스에 값이 없더라도 객체를 생성하여 글로벌 마냥 사용할 수 있다.
-> 전역변수의 감소, 클래스가 함수를 가지도록 하여 간단하게 사용할 수 있다.

사용 방법
def 함수이름(self):
	내용
	내용...

객체 지향은 수정이 용이하다.

생성자(constructor) -> def __init__(self):

def __init__(self, pos, delta):
	self.pos = pos;
	self.delta = delta
다른 생성자 생성 가능.

구조적으로 수정이 용이하고 가독성 있게 변하고 있다.

오브젝트들을 리스트로 만들어 그리는것을 관리한다.
-> 메인 함수의 코드는 늘어나지 않는다.

다형성 : 시키는 사람은 구체적으로 어떤일이 일어나는지 모른다.

구조를 단순하게! 더 좋게!

init draw update는 항상 있을 수 있으니 모든 클래스에 만들어 둘것, 그리고 빈것을 사용하면 그 내용은 pass로 해결

초기화
로직(이벤트처리, 업데이트)
랜더링
종료

team = [ Boy() for i in range(11) ]

team[0].~
team[1].~
...
이런식으로 반복문을 사용하여 여러 객체를 한번에 생성할 수 있다.


import random

random.randint(a, b) : a ~ b 사이의 값 랜덤 생성

선언 후 초기화 / 생성시 초기화 원하는 것을 골라 사용한다.

클래스를 나눈 의미가 있도록 사용한다.

파일 하나하나를 모듈이라고 한다.

import 같은 디렉터리(파일)  내부의 파일 이름
-> 그래야 파일이 합쳐진다.

함수를 사용하는 곳에선 모든 곳에서 import로 모듈을 include해준다.

사용방식은 [ from 모듈이름 import * ] 를 하면 된다.
단, 이 방식은 같은 이름을 가진 클래스가 있을 경우 오류가 날 수 있다.
그땐 [ from 모듈이름 import 클래스이름 as 별명 ] 로 한다.

모듈별로 나누게 된다면, 모듈 각각 따로 실행은 가능하다.
단, 따로 출력하는 부분이 없다면 바로 끝난다.

파이썬에서 객체는 singleton구조마냥 동작한다.

__name__ -> 클래스 객체의 이름을 return한다.
단, 모듈 자체만으로 움직이는 경우 __name__은 __main__을 출력한다.
이것으로 테스트 코드인지 진짜 전부 다 실행시키는 것인지 확인할 수 있다.
-> 모듈이 임포트 되는 경우와 직접 실행되는 경우를 파악할 수 있다.


Scene, GameScene -> 입력 방식이 달라지는 경우 장면별로 구분한다.
각 장면은 입력받는 것들이 행동하는 하는 방식이 전부 다를 수 있기에 구분한다.

핸들 이벤트를 여러개를 사용하여 장면을 구분한다. -> 분기하지 말자.(다형성을 이용해!!!)

장면을 관리해주는 뼈대를 만들어 준다. -> 프레임워크

게임 프로그램은 게임의 여러 상태(모드, 씬)가 합쳐져서 만들어진다.

우리가 만드는 게임의 대략적인 구조를 그려서 설명한다.
구조의 내용과 각 구조별로 넘어가는 관계(전환)와 방법을 그리는 것이 과제 또는 중간고사가 나온다.

다음번에 할 것 -> 로고 상태, 타이틀 상태, 메인 상태를 만들어 본다. 각 상태는 독립적인 파일로 이루어져 있기 때문에
서로 연관되지 않고 수정할 수 있다.











